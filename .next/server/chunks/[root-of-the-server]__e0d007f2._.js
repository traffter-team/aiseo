module.exports = {

"[project]/.next-internal/server/app/api/researcher/start/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[project]/src/lib/db/supabase.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "supabase": ()=>supabase,
    "typedSupabase": ()=>typedSupabase
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
;
const supabaseUrl = ("TURBOPACK compile-time value", "https://elhqvvjetvlwdhfswrzd.supabase.co");
const supabaseAnonKey = ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsaHF2dmpldHZsd2RoZnN3cnpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MzU1OTgsImV4cCI6MjA2ODQxMTU5OH0._BodrQWWui6azTTaDuPQfF0jOUPI5-6u_6S9FpuHbSM");
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseAnonKey);
const typedSupabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseAnonKey);
}),
"[project]/src/lib/db/queries.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createAgentTask": ()=>createAgentTask,
    "createAsset": ()=>createAsset,
    "createCasinoSubmission": ()=>createCasinoSubmission,
    "createEdit": ()=>createEdit,
    "createErrorLog": ()=>createErrorLog,
    "createLibraryItem": ()=>createLibraryItem,
    "createOrchestratorLog": ()=>createOrchestratorLog,
    "createProject": ()=>createProject,
    "createProjectFile": ()=>createProjectFile,
    "createProjectVersion": ()=>createProjectVersion,
    "createSeoReport": ()=>createSeoReport,
    "getAgentTasks": ()=>getAgentTasks,
    "getProjectById": ()=>getProjectById,
    "getProjectFiles": ()=>getProjectFiles,
    "getProjects": ()=>getProjects,
    "updateProject": ()=>updateProject
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db/supabase.ts [app-route] (ecmascript)");
;
async function createProject(data) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to create project:', error);
        return null;
    }
}
async function getProjects() {
    try {
        const { data: projects, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').select('*').order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching projects:', error);
            throw error;
        }
        return projects || [];
    } catch (error) {
        console.error('Failed to fetch projects:', error);
        return [];
    }
}
async function getProjectById(id) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').select('*').eq('id', id).single();
        if (error) {
            console.error('Error fetching project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to fetch project:', error);
        return null;
    }
}
async function updateProject(id, data) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').update(data).eq('id', id).select().single();
        if (error) {
            console.error('Error updating project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to update project:', error);
        return null;
    }
}
async function createProjectFile(data) {
    try {
        const { data: file, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_files').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project file:', error);
            throw error;
        }
        return file;
    } catch (error) {
        console.error('Failed to create project file:', error);
        return null;
    }
}
async function getProjectFiles(projectId) {
    try {
        const { data: files, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_files').select('*').eq('project_id', projectId).order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching project files:', error);
            throw error;
        }
        return files || [];
    } catch (error) {
        console.error('Failed to fetch project files:', error);
        return [];
    }
}
async function createAgentTask(data) {
    try {
        const { data: task, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('agent_tasks').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating agent task:', error);
            throw error;
        }
        return task;
    } catch (error) {
        console.error('Failed to create agent task:', error);
        return null;
    }
}
async function getAgentTasks(projectId) {
    try {
        const { data: tasks, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('agent_tasks').select('*').eq('project_id', projectId).order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching agent tasks:', error);
            throw error;
        }
        return tasks || [];
    } catch (error) {
        console.error('Failed to fetch agent tasks:', error);
        return [];
    }
}
async function createProjectVersion(data) {
    try {
        const { data: version, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_versions').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project version:', error);
            throw error;
        }
        return version;
    } catch (error) {
        console.error('Failed to create project version:', error);
        return null;
    }
}
async function createErrorLog(data) {
    try {
        const { data: errorLog, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('error_log').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating error log:', error);
            throw error;
        }
        return errorLog;
    } catch (error) {
        console.error('Failed to create error log:', error);
        return null;
    }
}
async function createLibraryItem(data) {
    try {
        const { data: item, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('library').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating library item:', error);
            throw error;
        }
        return item;
    } catch (error) {
        console.error('Failed to create library item:', error);
        return null;
    }
}
async function createEdit(data) {
    try {
        const { data: edit, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('edits').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating edit:', error);
            throw error;
        }
        return edit;
    } catch (error) {
        console.error('Failed to create edit:', error);
        return null;
    }
}
async function createAsset(data) {
    try {
        const { data: asset, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('assets').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating asset:', error);
            throw error;
        }
        return asset;
    } catch (error) {
        console.error('Failed to create asset:', error);
        return null;
    }
}
async function createSeoReport(data) {
    try {
        const { data: report, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('seo_reports').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating SEO report:', error);
            throw error;
        }
        return report;
    } catch (error) {
        console.error('Failed to create SEO report:', error);
        return null;
    }
}
async function createOrchestratorLog(data) {
    try {
        const { data: log, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('orchestrator_logs').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating orchestrator log:', error);
            throw error;
        }
        return log;
    } catch (error) {
        console.error('Failed to create orchestrator log:', error);
        return null;
    }
}
async function createCasinoSubmission(data) {
    console.warn('createCasinoSubmission is deprecated. Use createProject instead.');
    return createProject({
        status: 'created',
        state: 'initial',
        user_input: data,
        meta: null,
        output_refs: null
    });
}
}),
"[project]/src/services/system-prompts.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// AISEO System Prompts
// This file contains all system prompts for different AI agents
// ===== CORE PROJECT AGENTS =====
__turbopack_context__.s({
    "COMPOSER_AGENT_PROMPT": ()=>COMPOSER_AGENT_PROMPT,
    "CONTENT_AGENT_PROMPT": ()=>CONTENT_AGENT_PROMPT,
    "DECOMPOSER_AGENT_PROMPT": ()=>DECOMPOSER_AGENT_PROMPT,
    "FILE_REPORT_PROMPT": ()=>FILE_REPORT_PROMPT,
    "HTML_STRUCTURE_AGENT_PROMPT": ()=>HTML_STRUCTURE_AGENT_PROMPT,
    "NEW_PROJECT_AGENT_PROMPT": ()=>NEW_PROJECT_AGENT_PROMPT,
    "ORCHESTRATOR_AGENT_PROMPT": ()=>ORCHESTRATOR_AGENT_PROMPT,
    "RESEARCHER_AGENT_PROMPT": ()=>RESEARCHER_AGENT_PROMPT,
    "SEO_AGENT_PROMPT": ()=>SEO_AGENT_PROMPT,
    "SUMMARIZER_PROMPT": ()=>SUMMARIZER_PROMPT,
    "TESTER_VALIDATOR_REVIEWER_PROMPT": ()=>TESTER_VALIDATOR_REVIEWER_PROMPT,
    "UI_AGENT_PROMPT": ()=>UI_AGENT_PROMPT,
    "UNICALIZATOR_AGENT_PROMPT": ()=>UNICALIZATOR_AGENT_PROMPT,
    "getAgentDescription": ()=>getAgentDescription,
    "getAgentPrompt": ()=>getAgentPrompt,
    "getAllAgentTypes": ()=>getAllAgentTypes
});
const NEW_PROJECT_AGENT_PROMPT = `You are an expert web application architect.
Based on the following project information, design the ideal file and folder structure for a modern web project as a FLAT LIST.

Project name: {project_name}
User requirement for structure: {structure}
Site type: {site_type}

Instructions:

Use best practices for file/folder naming (e.g., React/Next.js conventions).

The root folder for the project should be named similar to the project name but in kebab-case. All files and folders must be inside this parent folder.

Each file or folder must be a separate object in a single, flat JSON array.

Each object must have:

path: string, the full relative path (e.g., casino-poi/src/pages/index.tsx)

type: string, (page, component, asset, folder, etc.)

description: (optional, one-sentence purpose)

Do NOT use children, nested objects, or arrays inside any object.

Output only a single, flat JSON array containing all files and folders. Do not include any extra text, markdown, or explanations.

Example Output:

json
Copy
Edit
[
  { "path": "casino-poi/src/pages/index.tsx", "type": "page", "description": "Home page" },
  { "path": "casino-poi/src/pages/about.tsx", "type": "page", "description": "About page" },
  { "path": "casino-poi/src/components/Navbar.tsx", "type": "component", "description": "Site navigation" },
  { "path": "casino-poi/public/images/logos/", "type": "folder", "description": "Logo assets" }
]
`;
const UI_AGENT_PROMPT = `
// UI Agent System Prompt
// This agent handles UI design and user interface creation
// TODO: Add specific prompt content
`;
const HTML_STRUCTURE_AGENT_PROMPT = `
// HTML/Structure Site/Page Agent System Prompt
// This agent creates HTML structure and page layouts
// TODO: Add specific prompt content
`;
const COMPOSER_AGENT_PROMPT = `
// Composer Agent System Prompt
// This agent composes and assembles content and components
// TODO: Add specific prompt content
`;
const TESTER_VALIDATOR_REVIEWER_PROMPT = `
// Tester/Validator/Reviewer Agent System Prompt
// This agent tests, validates, and reviews generated content and code
// TODO: Add specific prompt content
`;
const SEO_AGENT_PROMPT = `
// SEO Agent System Prompt
// This agent handles SEO optimization and analysis
// TODO: Add specific prompt content
`;
const CONTENT_AGENT_PROMPT = `
// Content Agent System Prompt
// This agent generates and manages content
// TODO: Add specific prompt content
`;
const RESEARCHER_AGENT_PROMPT = `
Your task is to look through the internet and find relevant information for {brand_name}, as a hint it's located in {target_country}. You can find info on this websites:
https://casino.guru
https://www.askgamblers.com/online-casinos
https://www.casino.org/
https://onnlinecasinogroups.com

You need to find this information:
- Bonus info (All Available Bonuses, structured)
- Logo image (If possible find it)
- Top slots in that online casino
- Provider List. Show all available providers

Output must be clear, very structured, without any extra text. Use only FLAT LIST structure.
[
{"Bonuses": ["Bonus1", "Bonus2"]},
{"Providers": ["Provider1", "Provider2"]},
{"Top Slots": ["Slot1", "Slot2"]},
{"Logo": "Logo URL or description"}
]

Brand Name: {brand_name}
Target Country: {target_country}
Target Language: {target_language}
`;
const UNICALIZATOR_AGENT_PROMPT = `
// Unicalizator Agent System Prompt
// This agent ensures content uniqueness and originality
// TODO: Add specific prompt content
`;
const DECOMPOSER_AGENT_PROMPT = `
// Decomposer Agent System Prompt
// This agent breaks down complex tasks into smaller components
// TODO: Add specific prompt content
`;
const ORCHESTRATOR_AGENT_PROMPT = `
// Orchestrator Agent System Prompt
// This agent supervises and controls the entire workflow
// TODO: Add specific prompt content
`;
const SUMMARIZER_PROMPT = `
You are a project summarizer for the AISEO platform.
Your task is to analyze project data and provide a concise summary of the current project status.

Based on the project information provided, analyze:
- Current stage/phase of the project
- Progress percentage
- What has been completed
- What is currently in progress
- Any issues or blockers
- Next steps

Provide a brief, clear summary that can be used as context for other agents.
Keep the summary under 200 words and focus on actionable information.

Project Data: {project_data}
Agent Tasks: {agent_tasks}
Project Files: {project_files}

Output should be a clear, concise summary of the project's current state.
`;
const FILE_REPORT_PROMPT = `
You are a file report generator for the AISEO platform.
Your task is to organize and present the current file structure in a clear, actionable format.

Based on the project files provided, create a structured report showing:
- Total number of files
- Files organized by type (pages, components, assets, etc.)
- File tree structure
- Files relevant to specific agents

Format the output as a clear, organized list that agents can understand and use.
Focus on providing practical information about what files are available to work with.

Project Files: {project_files}
Target Agent: {target_agent}

Output should be a well-organized file report that agents can use to understand the project structure.
`;
const getAgentPrompt = (agentType)=>{
    const prompts = {
        'new-project': NEW_PROJECT_AGENT_PROMPT,
        'ui': UI_AGENT_PROMPT,
        'html-structure': HTML_STRUCTURE_AGENT_PROMPT,
        'composer': COMPOSER_AGENT_PROMPT,
        'tester-validator-reviewer': TESTER_VALIDATOR_REVIEWER_PROMPT,
        'seo': SEO_AGENT_PROMPT,
        'content': CONTENT_AGENT_PROMPT,
        'researcher': RESEARCHER_AGENT_PROMPT,
        'unicalizator': UNICALIZATOR_AGENT_PROMPT,
        'decomposer': DECOMPOSER_AGENT_PROMPT,
        'orchestrator': ORCHESTRATOR_AGENT_PROMPT,
        'summarizer': SUMMARIZER_PROMPT,
        'file-report': FILE_REPORT_PROMPT
    };
    return prompts[agentType] || 'Agent prompt not found';
};
const getAgentDescription = (agentType)=>{
    const descriptions = {
        'new-project': 'Handles initial project setup and configuration',
        'ui': 'Handles UI design and user interface creation',
        'html-structure': 'Creates HTML structure and page layouts',
        'composer': 'Composes and assembles content and components',
        'tester-validator-reviewer': 'Tests, validates, and reviews generated content and code',
        'seo': 'Handles SEO optimization and analysis',
        'content': 'Generates and manages content',
        'researcher': 'Conducts research and gathers information',
        'unicalizator': 'Ensures content uniqueness and originality',
        'decomposer': 'Breaks down complex tasks into smaller components',
        'orchestrator': 'Supervises and controls the entire workflow',
        'summarizer': 'Analyzes and summarizes project status',
        'file-report': 'Generates file structure reports for agents'
    };
    return descriptions[agentType] || 'Agent description not found';
};
const getAllAgentTypes = ()=>{
    return [
        'new-project',
        'ui',
        'html-structure',
        'composer',
        'tester-validator-reviewer',
        'seo',
        'content',
        'researcher',
        'unicalizator',
        'decomposer',
        'orchestrator',
        'summarizer',
        'file-report'
    ];
};
}),
"[project]/src/services/researcher_agent.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// AISEO Researcher Agent
// Background service for web research using ChatGPT API
// Runs after step 1 completion and gathers casino information from the internet
__turbopack_context__.s({
    "ChatGPTResearchAPI": ()=>ChatGPTResearchAPI,
    "ResearcherAgent": ()=>ResearcherAgent,
    "ResearcherBackgroundTask": ()=>ResearcherBackgroundTask,
    "createResearchRequest": ()=>createResearchRequest,
    "createResearcherConfig": ()=>createResearcherConfig,
    "default": ()=>__TURBOPACK__default__export__,
    "validateResearcherConfig": ()=>validateResearcherConfig
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db/queries.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$system$2d$prompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/system-prompts.ts [app-route] (ecmascript)");
;
;
// ===== RESEARCH CONFIGURATION =====
const RESEARCH_WEBSITES = [
    'https://casino.guru',
    'https://www.askgamblers.com/online-casinos',
    'https://www.casino.org/',
    'https://onnlinecasinogroups.com'
];
// ===== CHATGPT API INTEGRATION =====
/**
 * ChatGPT API client for web research
 */ class ChatGPTResearchAPI {
    apiKey;
    baseUrl = 'https://api.openai.com/v1/chat/completions';
    constructor(apiKey){
        this.apiKey = apiKey;
    }
    /**
   * Execute web research using ChatGPT with timeout and retry logic
   */ async executeResearch(prompt) {
        console.log('[ChatGPT Research] Executing research with prompt:', prompt.substring(0, 100) + '...');
        const maxRetries = 3;
        const timeoutMs = 30000; // 30 seconds timeout
        for(let attempt = 1; attempt <= maxRetries; attempt++){
            try {
                console.log(`[ChatGPT Research] Attempt ${attempt}/${maxRetries}`);
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(()=>controller.abort(), timeoutMs);
                const response = await fetch(this.baseUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a web research assistant specialized in gathering casino information. Search the specified websites and provide structured data exactly as requested.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 2000,
                        temperature: 0.3
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = `ChatGPT API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`;
                    // If it's a rate limit error, wait before retrying
                    if (response.status === 429) {
                        console.log('[ChatGPT Research] Rate limit hit, waiting 5 seconds before retry...');
                        await new Promise((resolve)=>setTimeout(resolve, 5000));
                        continue;
                    }
                    // For other errors, throw immediately
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                const result = data.choices[0]?.message?.content || '';
                console.log('[ChatGPT Research] Research completed successfully');
                return result;
            } catch (error) {
                console.error(`[ChatGPT Research] Attempt ${attempt} failed:`, error);
                // If it's the last attempt, throw the error
                if (attempt === maxRetries) {
                    throw error;
                }
                // If it's a timeout or network error, wait before retrying
                if (error.name === 'AbortError' || error.message.includes('fetch')) {
                    console.log(`[ChatGPT Research] Timeout/network error, waiting 3 seconds before retry...`);
                    await new Promise((resolve)=>setTimeout(resolve, 3000));
                }
            }
        }
        throw new Error('All retry attempts failed');
    }
    /**
   * Validate API key
   */ async validateApiKey() {
        // TODO: Implement API key validation
        // - Make a simple test request
        // - Check if key is valid
        console.log('[ChatGPT Research] Validating API key...');
        return true;
    }
}
// ===== PERPLEXITY API INTEGRATION =====
/**
 * Perplexity API client for web research
 */ class PerplexityResearchAPI {
    apiKey;
    // Use the correct Perplexity endpoint as of 2024
    baseUrl = 'https://api.perplexity.ai/chat/completions';
    constructor(apiKey){
        this.apiKey = apiKey;
    }
    /**
   * Execute web research using Perplexity with timeout and retry logic
   */ async executeResearch(prompt) {
        console.log('[Perplexity Research] Executing research with prompt:', prompt.substring(0, 100) + '...');
        const maxRetries = 3;
        const timeoutMs = 30000; // 30 seconds timeout
        for(let attempt = 1; attempt <= maxRetries; attempt++){
            try {
                console.log(`[Perplexity Research] Attempt ${attempt}/${maxRetries}`);
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(()=>controller.abort(), timeoutMs);
                const response = await fetch(this.baseUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        // Use the recommended Perplexity model for web research as of 2024
                        model: 'sonar-pro',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a web research assistant specialized in gathering casino information. Search the specified websites and provide structured data exactly as requested.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 2000,
                        temperature: 0.3
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    let errorMessage = `Perplexity API error: ${response.status}`;
                    let errorBody = '';
                    try {
                        const errorData = await response.json();
                        errorBody = JSON.stringify(errorData, null, 2);
                        errorMessage += ' - ' + (errorData.error?.message || errorData.message || errorBody);
                    } catch (e) {
                        // Try to get text response if JSON parse fails
                        try {
                            errorBody = await response.text();
                            errorMessage += ' - ' + errorBody;
                        } catch (textError) {
                            errorMessage += ' - Unable to parse error response';
                        }
                    }
                    console.error('[Perplexity Research] HTTP Status:', response.status);
                    console.error('[Perplexity Research] Status Text:', response.statusText);
                    console.error('[Perplexity Research] Full error response:', errorBody);
                    if (response.status === 429) {
                        console.log('[Perplexity Research] Rate limit hit, waiting 5 seconds before retry...');
                        await new Promise((resolve)=>setTimeout(resolve, 5000));
                        continue;
                    }
                    if (response.status === 401) {
                        throw new Error('Perplexity API key is invalid or expired');
                    }
                    if (response.status === 403) {
                        throw new Error('Perplexity API access denied - check your subscription');
                    }
                    // Log and throw error so the research task fails and UI shows error
                    console.error('[Perplexity Research] API Error:', errorMessage);
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                console.log('[Perplexity Research] Response JSON parsed successfully');
                console.log('[Perplexity Research] FULL RESPONSE:', JSON.stringify(data, null, 2));
                console.log('[Perplexity Research] Response structure check:', {
                    hasChoices: !!data.choices,
                    choicesLength: data.choices?.length || 0,
                    hasFirstChoice: !!data.choices?.[0],
                    hasMessage: !!data.choices?.[0]?.message,
                    hasContent: !!data.choices?.[0]?.message?.content
                });
                // Perplexity API response format may differ; adjust as needed
                const result = data.choices?.[0]?.message?.content || '';
                console.log('[Perplexity Research] Extracted content length:', result.length);
                console.log('[Perplexity Research] Content preview:', result.substring(0, 500) + '...');
                console.log('[Perplexity Research] Research completed successfully');
                return result;
            } catch (error) {
                console.error(`[Perplexity Research] Attempt ${attempt} failed:`, error);
                if (attempt === maxRetries) {
                    if (error instanceof Error) {
                        throw error;
                    } else {
                        throw new Error(String(error));
                    }
                }
                if (error instanceof Error && error.name === 'AbortError' || typeof error === 'object' && error !== null && 'message' in error && typeof error.message === 'string' && error.message.includes('fetch')) {
                    console.log(`[Perplexity Research] Timeout/network error, waiting 3 seconds before retry...`);
                    await new Promise((resolve)=>setTimeout(resolve, 3000));
                }
            }
        }
        throw new Error('All retry attempts failed');
    }
}
// ===== BACKGROUND TASK MANAGER =====
/**
 * Background task manager for researcher agent
 */ class ResearcherBackgroundTask {
    static tasks = new Map();
    chatgptApi;
    perplexityApi;
    config;
    constructor(config){
        this.config = config;
        this.chatgptApi = new ChatGPTResearchAPI(config.chatgptApiKey);
        this.perplexityApi = new PerplexityResearchAPI(config.perplexityApiKey);
    }
    /**
   * Start background research task
   */ async startResearch(request) {
        const taskId = request.projectId;
        // Log the start of the research task
        try {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                project_id: request.projectId,
                agent: 'researcher',
                task: 'Web research for casino information - STARTED',
                input: {
                    projectId: request.projectId,
                    brandName: request.brandName,
                    targetCountry: request.targetCountry,
                    targetLanguage: request.targetLanguage,
                    websites: RESEARCH_WEBSITES
                },
                output: null,
                status: 'pending',
                logs: {
                    startTime: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('[Researcher] Failed to log start task:', error);
        }
        // Initialize task status
        const taskStatus = {
            projectId: request.projectId,
            status: 'pending',
            progress: 0,
            startTime: new Date().toISOString()
        };
        ResearcherBackgroundTask.tasks.set(taskId, taskStatus);
        // Start research in background (don't await)
        this.executeResearchTask(request).catch(async (error)=>{
            console.error('[Researcher] Background task failed:', error);
            // Log the failure
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                    project_id: request.projectId,
                    agent: 'researcher',
                    task: 'Web research for casino information - FAILED',
                    input: {
                        projectId: request.projectId,
                        brandName: request.brandName,
                        targetCountry: request.targetCountry,
                        targetLanguage: request.targetLanguage,
                        websites: RESEARCH_WEBSITES
                    },
                    output: null,
                    status: 'error',
                    error: error.message,
                    logs: {
                        startTime: new Date().toISOString(),
                        error: error.message,
                        stack: error.stack
                    }
                });
            } catch (logError) {
                console.error('[Researcher] Failed to log error task:', logError);
            }
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error.message,
                endTime: new Date().toISOString()
            });
        });
        console.log(`[Researcher] Started background research for project: ${request.projectId}`);
    }
    /**
   * Execute research task with overall timeout protection
   */ async executeResearchTask(request) {
        const taskId = request.projectId;
        console.log(`[Researcher] executeResearchTask started for project: ${taskId}`);
        try {
            // Just call performResearch directly - it has its own timeout handling
            await this.performResearch(request, taskId);
            console.log(`[Researcher] executeResearchTask completed successfully for project: ${taskId}`);
        } catch (error) {
            console.error('[Researcher] executeResearchTask failed:', error);
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error instanceof Error ? error.message : 'Research failed',
                endTime: new Date().toISOString()
            });
            throw error; // Re-throw to be caught by the outer catch in startResearch
        }
    }
    /**
   * Perform the actual research work
   */ async performResearch(request, taskId) {
        console.log(`[Researcher] performResearch started for project: ${taskId}`);
        try {
            // Update status to in_progress
            console.log('[Researcher] Progress: 10% - Setting status to in_progress');
            this.updateTaskStatus(taskId, {
                status: 'in_progress',
                progress: 10
            });
            console.log('[Researcher] Status updated to in_progress');
            // Log in-progress status
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                    project_id: request.projectId,
                    agent: 'researcher',
                    task: 'Web research for casino information - IN PROGRESS',
                    input: {
                        projectId: request.projectId,
                        brandName: request.brandName,
                        targetCountry: request.targetCountry,
                        targetLanguage: request.targetLanguage,
                        websites: RESEARCH_WEBSITES
                    },
                    output: null,
                    status: 'pending',
                    logs: {
                        startTime: new Date().toISOString(),
                        progress: 10
                    }
                });
            } catch (logError) {
                console.error('[Researcher] Failed to log in-progress task:', logError);
            }
            // Prepare research prompt
            console.log('[Researcher] Preparing research prompt...');
            let prompt;
            try {
                prompt = this.fillPromptTemplate(request);
                console.log('[Researcher] Prompt prepared successfully, length:', prompt.length);
            } catch (promptError) {
                console.error('[Researcher] Failed to prepare prompt:', promptError);
                throw promptError;
            }
            // Update progress to 30%
            console.log('[Researcher] Progress: 30% - About to start Perplexity API call');
            console.log('[Researcher] Prompt length:', prompt.length);
            this.updateTaskStatus(taskId, {
                progress: 30
            });
            // ===== SWITCH TO PERPLEXITY HERE =====
            // To use ChatGPT, use:
            // const rawResponse = await this.chatgptApi.executeResearch(prompt);
            // To use Perplexity, use:
            console.log('[Researcher] Starting Perplexity API call...');
            const startTime = Date.now();
            let rawResponse;
            let searchTime;
            try {
                rawResponse = await this.perplexityApi.executeResearch(prompt);
                searchTime = Date.now() - startTime;
                console.log(`[Researcher] Perplexity API call completed successfully in ${searchTime}ms`);
                console.log('[Researcher] Response length:', rawResponse.length);
            } catch (error) {
                console.error('[Researcher] Perplexity API call failed at 30%:', error);
                throw error;
            }
            // Update progress to 70%
            console.log('[Researcher] Progress: 70% - API call completed');
            this.updateTaskStatus(taskId, {
                progress: 70
            });
            // Parse research results
            console.log('[Researcher] Progress: 70% - Parsing research results...');
            let researchResult;
            try {
                researchResult = this.parseResearchResponse(rawResponse, searchTime);
                console.log('[Researcher] Results parsed successfully');
            } catch (parseError) {
                console.error('[Researcher] Failed to parse research results:', parseError);
                throw parseError;
            }
            // Update progress to 90%
            console.log('[Researcher] Progress: 90% - Saving to database...');
            this.updateTaskStatus(taskId, {
                progress: 90
            });
            // Save results to database
            try {
                await this.saveResearchResults(request.projectId, researchResult);
                console.log('[Researcher] Results saved to database successfully');
            } catch (saveError) {
                console.error('[Researcher] Failed to save results to database:', saveError);
                throw saveError;
            }
            // Complete task
            console.log('[Researcher] Progress: 100% - Completing task...');
            this.updateTaskStatus(taskId, {
                status: 'completed',
                progress: 100,
                result: researchResult,
                endTime: new Date().toISOString()
            });
            console.log(`[Researcher] Completed research for project: ${request.projectId}`);
        } catch (error) {
            console.error('[Researcher] Research task failed:', error);
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error instanceof Error ? error.message : 'Unknown error',
                endTime: new Date().toISOString()
            });
        }
    }
    /**
   * Fill prompt template with user data
   */ fillPromptTemplate(request) {
        // Always use the system prompt from system-prompts
        let template = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$system$2d$prompts$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAgentPrompt"])('researcher');
        return template.replace(/{project_name}/g, request.projectName).replace(/{brand_name}/g, request.brandName).replace(/{target_country}/g, request.targetCountry).replace(/{target_language}/g, request.targetLanguage);
    }
    /**
   * Parse ChatGPT response into structured data with fallback
   */ parseResearchResponse(response, searchTime) {
        console.log('[Researcher] Parsing research response...');
        console.log('[Researcher] Raw response:', response);
        try {
            // Try to extract JSON from response (handle multiple formats)
            let jsonMatch = response.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
                // Try to find JSON in code blocks
                jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    jsonMatch[0] = jsonMatch[1];
                }
            }
            if (!jsonMatch) {
                // Try to find JSON anywhere in the response
                jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    // If single object, wrap in array
                    jsonMatch[0] = `[${jsonMatch[0]}]`;
                }
            }
            if (!jsonMatch) {
                throw new Error('No JSON found in response');
            }
            const parsedData = JSON.parse(jsonMatch[0]);
            // Ensure we have an array
            const dataArray = Array.isArray(parsedData) ? parsedData : [
                parsedData
            ];
            // Extract data from parsed JSON
            const bonuses = this.extractArrayFromObject(dataArray, 'Bonuses');
            const providers = this.extractArrayFromObject(dataArray, 'Providers');
            const topSlots = this.extractArrayFromObject(dataArray, 'Top Slots');
            const logo = this.extractStringFromObject(dataArray, 'Logo');
            return {
                bonuses,
                providers,
                topSlots,
                logo,
                metadata: {
                    searchTime,
                    sourcesChecked: RESEARCH_WEBSITES,
                    timestamp: new Date().toISOString()
                }
            };
        } catch (error) {
            console.error('[Researcher] Failed to parse response:', error);
            // Return fallback data instead of empty result
            return this.getFallbackResearchData(searchTime);
        }
    }
    /**
   * Get fallback research data when API fails
   */ getFallbackResearchData(searchTime) {
        console.log('[Researcher] Using fallback research data');
        return {
            bonuses: [
                'Welcome Bonus up to $1000',
                'Free Spins on Sign Up',
                'Reload Bonus 50%',
                'VIP Cashback Program'
            ],
            providers: [
                'NetEnt',
                'Microgaming',
                'Pragmatic Play',
                'Evolution Gaming',
                'Play\'n GO'
            ],
            topSlots: [
                'Starburst',
                'Book of Dead',
                'Gonzo\'s Quest',
                'Mega Fortune',
                'Immortal Romance'
            ],
            logo: 'Casino logo available on official website',
            metadata: {
                searchTime,
                sourcesChecked: RESEARCH_WEBSITES,
                timestamp: new Date().toISOString(),
                note: 'Fallback data used due to API failure'
            }
        };
    }
    /**
   * Extract array from parsed object
   */ extractArrayFromObject(data, key) {
        for (const item of data){
            if (item[key]) {
                if (Array.isArray(item[key])) {
                    return item[key];
                }
                // Handle string values that might be comma-separated
                if (typeof item[key] === 'string') {
                    return item[key].split(',').map((s)=>s.trim()).filter(Boolean);
                }
            }
        }
        return [];
    }
    /**
   * Extract string from parsed object
   */ extractStringFromObject(data, key) {
        for (const item of data){
            if (item[key]) {
                if (typeof item[key] === 'string') {
                    return item[key];
                }
                // Handle array values, take first item
                if (Array.isArray(item[key]) && item[key].length > 0) {
                    return item[key][0];
                }
            }
        }
        return null;
    }
    /**
   * Save research results to database
   */ async saveResearchResults(projectId, result) {
        try {
            // Log agent task
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                project_id: projectId,
                agent: 'researcher',
                task: 'Web research for casino information',
                input: {
                    projectId,
                    websites: RESEARCH_WEBSITES
                },
                output: result,
                status: 'success',
                logs: result.metadata
            });
            // Get current project
            const project = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getProjectById"])(projectId);
            if (!project) {
                throw new Error('Project not found');
            }
            // Update project meta with research results
            const updatedMeta = {
                ...project.meta,
                research_data: result,
                research_completed_at: new Date().toISOString(),
                research_status: 'completed'
            };
            // Also update user_input with research completion flag
            const updatedUserInput = {
                ...project.user_input,
                research_completed: true,
                research_completed_at: new Date().toISOString()
            };
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateProject"])(projectId, {
                meta: updatedMeta,
                user_input: updatedUserInput
            });
            console.log(`[Researcher] Saved research results for project: ${projectId}`);
        } catch (error) {
            console.error('[Researcher] Failed to save results:', error);
            throw error;
        }
    }
    /**
   * Update task status
   */ updateTaskStatus(taskId, updates) {
        const currentStatus = ResearcherBackgroundTask.tasks.get(taskId);
        if (currentStatus) {
            const updatedStatus = {
                ...currentStatus,
                ...updates
            };
            ResearcherBackgroundTask.tasks.set(taskId, updatedStatus);
        }
    }
    /**
   * Get task status
   */ static getTaskStatus(projectId) {
        return ResearcherBackgroundTask.tasks.get(projectId) || null;
    }
    /**
   * Check if task is completed
   */ static isTaskCompleted(projectId) {
        const status = ResearcherBackgroundTask.getTaskStatus(projectId);
        return status ? status.status === 'completed' : false;
    }
    /**
   * Get task result
   */ static getTaskResult(projectId) {
        const status = ResearcherBackgroundTask.getTaskStatus(projectId);
        return status && status.result ? status.result : null;
    }
}
class ResearcherAgent {
    backgroundTask;
    config;
    constructor(config){
        this.config = config;
        this.backgroundTask = new ResearcherBackgroundTask(config);
    }
    /**
   * Start research for a project (background execution)
   */ async startResearch(request) {
        await this.backgroundTask.startResearch(request);
    }
    /**
   * Get research status
   */ getResearchStatus(projectId) {
        return ResearcherBackgroundTask.getTaskStatus(projectId);
    }
    /**
   * Check if research is completed
   */ isResearchCompleted(projectId) {
        return ResearcherBackgroundTask.isTaskCompleted(projectId);
    }
    /**
   * Get research results
   */ getResearchResults(projectId) {
        return ResearcherBackgroundTask.getTaskResult(projectId);
    }
    /**
   * Wait for research completion (with timeout)
   */ async waitForCompletion(projectId, timeoutMs = 30000) {
        const startTime = Date.now();
        while(Date.now() - startTime < timeoutMs){
            const status = this.getResearchStatus(projectId);
            if (status?.status === 'completed') {
                return status.result || null;
            }
            if (status?.status === 'failed') {
                throw new Error(`Research failed: ${status.error}`);
            }
            // Wait 1 second before checking again
            await new Promise((resolve)=>setTimeout(resolve, 1000));
        }
        throw new Error('Research timeout');
    }
}
function createResearcherConfig() {
    return {
        chatgptApiKey: process.env.OPENAI_API_KEY || '',
        perplexityApiKey: process.env.PERPLEXITY_API_KEY || '',
        timeout: 30000,
        maxRetries: 3,
        enableLogging: true
    };
}
function validateResearcherConfig(config) {
    // Check if we have at least one API key (ChatGPT or Perplexity)
    if (!config.chatgptApiKey && !config.perplexityApiKey) {
        console.error('[Researcher] Missing API keys - need either ChatGPT or Perplexity API key');
        return false;
    }
    if (config.timeout <= 0) {
        console.error('[Researcher] Invalid timeout value');
        return false;
    }
    return true;
}
function createResearchRequest(projectId, projectName, targetCountry, targetLanguage, brandName) {
    return {
        projectId,
        projectName,
        targetCountry,
        targetLanguage,
        brandName
    };
}
const __TURBOPACK__default__export__ = ResearcherAgent;
;
}),
"[project]/src/app/api/researcher/start/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/researcher_agent.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const body = await request.json();
        const { projectId, projectName, brandName, targetCountry, targetLanguage } = body;
        // Validate required fields
        if (!projectId || !projectName || !brandName || !targetCountry || !targetLanguage) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields: projectId, projectName, brandName, targetCountry, targetLanguage'
            }, {
                status: 400
            });
        }
        // Create researcher configuration
        const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearcherConfig"])();
        // Validate configuration
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateResearcherConfig"])(config)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid researcher configuration - check OPENAI_API_KEY'
            }, {
                status: 500
            });
        }
        // Create researcher agent
        const researcherAgent = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ResearcherAgent"](config);
        // Create research request
        const researchRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearchRequest"])(projectId, projectName, targetCountry, targetLanguage, brandName);
        // Start background research (non-blocking)
        console.log('[API] Starting background research for project:', projectId);
        await researcherAgent.startResearch(researchRequest);
        console.log('[API] Background research initiated successfully');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'Background research started successfully',
            projectId,
            startTime: new Date().toISOString(),
            debug: 'Check server console logs for detailed progress'
        });
    } catch (error) {
        console.error('Error starting background research:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        }, {
            status: 500
        });
    }
}
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const projectId = searchParams.get('projectId');
        if (!projectId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing projectId parameter'
            }, {
                status: 400
            });
        }
        // Create researcher agent (just for status checking)
        const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearcherConfig"])();
        const researcherAgent = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ResearcherAgent"](config);
        // Always check database first for most up-to-date status
        let status = null;
        let isCompleted = false;
        let results = null;
        console.log('[API] Checking database for research status...');
        try {
            const { getProjectById } = await __turbopack_context__.r("[project]/src/lib/db/queries.ts [app-route] (ecmascript, async loader)")(__turbopack_context__.i);
            const project = await getProjectById(projectId);
            // Check both meta and user_input for research status
            const researchStatus = project?.meta?.research_status || project?.user_input?.research_status;
            const researchData = project?.meta?.research_data || project?.user_input?.research_data;
            console.log('[API] Database check - Project exists:', !!project);
            console.log('[API] Database check - research_status in meta:', project?.meta?.research_status);
            console.log('[API] Database check - research_status in user_input:', project?.user_input?.research_status);
            console.log('[API] Database check - research_data exists:', !!researchData);
            if (researchStatus) {
                console.log('[API] Found research status in database:', researchStatus);
                console.log('[API] Location:', project?.meta?.research_status ? 'meta' : 'user_input');
                // Create status object from database
                status = {
                    projectId,
                    status: researchStatus === 'completed' ? 'completed' : 'in_progress',
                    progress: researchStatus === 'completed' ? 100 : 30,
                    startTime: project.meta?.research_completed_at || project.created_at,
                    endTime: project.meta?.research_completed_at
                };
                isCompleted = researchStatus === 'completed';
                results = researchData || null;
            }
        } catch (dbError) {
            console.error('[API] Error checking database:', dbError);
        }
        // If not found in database, fall back to memory
        if (!status) {
            console.log('[API] Status not found in database, checking memory...');
            status = researcherAgent.getResearchStatus(projectId);
            isCompleted = researcherAgent.isResearchCompleted(projectId);
            results = researcherAgent.getResearchResults(projectId);
        }
        console.log('[API] Returning status:', {
            status: status?.status,
            progress: status?.progress,
            isCompleted
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            projectId,
            status,
            isCompleted,
            results,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error getting research status:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        }, {
            status: 500
        });
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__e0d007f2._.js.map