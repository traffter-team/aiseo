module.exports = {

"[project]/.next-internal/server/app/api/researcher/start/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[project]/src/lib/db/supabase.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "supabase": ()=>supabase,
    "typedSupabase": ()=>typedSupabase
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
;
const supabaseUrl = ("TURBOPACK compile-time value", "https://elhqvvjetvlwdhfswrzd.supabase.co");
const supabaseAnonKey = ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsaHF2dmpldHZsd2RoZnN3cnpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MzU1OTgsImV4cCI6MjA2ODQxMTU5OH0._BodrQWWui6azTTaDuPQfF0jOUPI5-6u_6S9FpuHbSM");
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseAnonKey);
const typedSupabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(supabaseUrl, supabaseAnonKey);
}),
"[project]/src/lib/db/queries.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createAgentTask": ()=>createAgentTask,
    "createAsset": ()=>createAsset,
    "createCasinoSubmission": ()=>createCasinoSubmission,
    "createEdit": ()=>createEdit,
    "createErrorLog": ()=>createErrorLog,
    "createLibraryItem": ()=>createLibraryItem,
    "createOrchestratorLog": ()=>createOrchestratorLog,
    "createProject": ()=>createProject,
    "createProjectFile": ()=>createProjectFile,
    "createProjectVersion": ()=>createProjectVersion,
    "createSeoReport": ()=>createSeoReport,
    "getAgentTasks": ()=>getAgentTasks,
    "getProjectById": ()=>getProjectById,
    "getProjectFiles": ()=>getProjectFiles,
    "getProjects": ()=>getProjects,
    "updateProject": ()=>updateProject
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db/supabase.ts [app-route] (ecmascript)");
;
async function createProject(data) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to create project:', error);
        return null;
    }
}
async function getProjects() {
    try {
        const { data: projects, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').select('*').order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching projects:', error);
            throw error;
        }
        return projects || [];
    } catch (error) {
        console.error('Failed to fetch projects:', error);
        return [];
    }
}
async function getProjectById(id) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').select('*').eq('id', id).single();
        if (error) {
            console.error('Error fetching project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to fetch project:', error);
        return null;
    }
}
async function updateProject(id, data) {
    try {
        const { data: project, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('projects').update(data).eq('id', id).select().single();
        if (error) {
            console.error('Error updating project:', error);
            throw error;
        }
        return project;
    } catch (error) {
        console.error('Failed to update project:', error);
        return null;
    }
}
async function createProjectFile(data) {
    try {
        const { data: file, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_files').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project file:', error);
            throw error;
        }
        return file;
    } catch (error) {
        console.error('Failed to create project file:', error);
        return null;
    }
}
async function getProjectFiles(projectId) {
    try {
        const { data: files, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_files').select('*').eq('project_id', projectId).order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching project files:', error);
            throw error;
        }
        return files || [];
    } catch (error) {
        console.error('Failed to fetch project files:', error);
        return [];
    }
}
async function createAgentTask(data) {
    try {
        const { data: task, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('agent_tasks').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating agent task:', error);
            throw error;
        }
        return task;
    } catch (error) {
        console.error('Failed to create agent task:', error);
        return null;
    }
}
async function getAgentTasks(projectId) {
    try {
        const { data: tasks, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('agent_tasks').select('*').eq('project_id', projectId).order('created_at', {
            ascending: false
        });
        if (error) {
            console.error('Error fetching agent tasks:', error);
            throw error;
        }
        return tasks || [];
    } catch (error) {
        console.error('Failed to fetch agent tasks:', error);
        return [];
    }
}
async function createProjectVersion(data) {
    try {
        const { data: version, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('project_versions').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating project version:', error);
            throw error;
        }
        return version;
    } catch (error) {
        console.error('Failed to create project version:', error);
        return null;
    }
}
async function createErrorLog(data) {
    try {
        const { data: errorLog, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('error_log').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating error log:', error);
            throw error;
        }
        return errorLog;
    } catch (error) {
        console.error('Failed to create error log:', error);
        return null;
    }
}
async function createLibraryItem(data) {
    try {
        const { data: item, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('library').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating library item:', error);
            throw error;
        }
        return item;
    } catch (error) {
        console.error('Failed to create library item:', error);
        return null;
    }
}
async function createEdit(data) {
    try {
        const { data: edit, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('edits').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating edit:', error);
            throw error;
        }
        return edit;
    } catch (error) {
        console.error('Failed to create edit:', error);
        return null;
    }
}
async function createAsset(data) {
    try {
        const { data: asset, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('assets').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating asset:', error);
            throw error;
        }
        return asset;
    } catch (error) {
        console.error('Failed to create asset:', error);
        return null;
    }
}
async function createSeoReport(data) {
    try {
        const { data: report, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('seo_reports').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating SEO report:', error);
            throw error;
        }
        return report;
    } catch (error) {
        console.error('Failed to create SEO report:', error);
        return null;
    }
}
async function createOrchestratorLog(data) {
    try {
        const { data: log, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$supabase$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["supabase"].from('orchestrator_logs').insert([
            data
        ]).select().single();
        if (error) {
            console.error('Error creating orchestrator log:', error);
            throw error;
        }
        return log;
    } catch (error) {
        console.error('Failed to create orchestrator log:', error);
        return null;
    }
}
async function createCasinoSubmission(data) {
    console.warn('createCasinoSubmission is deprecated. Use createProject instead.');
    return createProject({
        status: 'created',
        state: 'initial',
        user_input: data,
        meta: null,
        output_refs: null
    });
}
}),
"[project]/src/services/researcher_agent.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// AISEO Researcher Agent
// Background service for web research using ChatGPT API
// Runs after step 1 completion and gathers casino information from the internet
__turbopack_context__.s({
    "ChatGPTResearchAPI": ()=>ChatGPTResearchAPI,
    "ResearcherAgent": ()=>ResearcherAgent,
    "ResearcherBackgroundTask": ()=>ResearcherBackgroundTask,
    "createResearchRequest": ()=>createResearchRequest,
    "createResearcherConfig": ()=>createResearcherConfig,
    "default": ()=>__TURBOPACK__default__export__,
    "validateResearcherConfig": ()=>validateResearcherConfig
});
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db/queries.ts [app-route] (ecmascript)");
;
// ===== RESEARCH CONFIGURATION =====
const RESEARCH_WEBSITES = [
    'https://casino.guru',
    'https://www.askgamblers.com/online-casinos',
    'https://www.casino.org/',
    'https://onnlinecasinogroups.com'
];
const RESEARCH_PROMPT_TEMPLATE = `Your task is to look through the internet and find relevant information for {project_name}, as a hint it's located in {target_country}. You can find info on this websites:
https://casino.guru
https://www.askgamblers.com/online-casinos
https://www.casino.org/
https://onnlinecasinogroups.com

You need to find this information:
- Bonus info (All Available Bonuses, structured)
- Logo image (If possible find it)
- Top slots in that online casino
- Provider List. Show all available providers

Output must be clear, very structured, without any extra text. Use only FLAT LIST structure.
[
{"Bonuses": ["Bonus1", "Bonus2"]},
{"Providers": ["Provider1", "Provider2"]},
{"Top Slots": ["Slot1", "Slot2"]},
{"Logo": "Logo URL or description"}
]`;
// ===== CHATGPT API INTEGRATION =====
/**
 * ChatGPT API client for web research
 */ class ChatGPTResearchAPI {
    apiKey;
    baseUrl = 'https://api.openai.com/v1/chat/completions';
    constructor(apiKey){
        this.apiKey = apiKey;
    }
    /**
   * Execute web research using ChatGPT with timeout and retry logic
   */ async executeResearch(prompt) {
        console.log('[ChatGPT Research] Executing research with prompt:', prompt.substring(0, 100) + '...');
        const maxRetries = 3;
        const timeoutMs = 30000; // 30 seconds timeout
        for(let attempt = 1; attempt <= maxRetries; attempt++){
            try {
                console.log(`[ChatGPT Research] Attempt ${attempt}/${maxRetries}`);
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(()=>controller.abort(), timeoutMs);
                const response = await fetch(this.baseUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a web research assistant specialized in gathering casino information. Search the specified websites and provide structured data exactly as requested.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 2000,
                        temperature: 0.3
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = `ChatGPT API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`;
                    // If it's a rate limit error, wait before retrying
                    if (response.status === 429) {
                        console.log('[ChatGPT Research] Rate limit hit, waiting 5 seconds before retry...');
                        await new Promise((resolve)=>setTimeout(resolve, 5000));
                        continue;
                    }
                    // For other errors, throw immediately
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                const result = data.choices[0]?.message?.content || '';
                console.log('[ChatGPT Research] Research completed successfully');
                return result;
            } catch (error) {
                console.error(`[ChatGPT Research] Attempt ${attempt} failed:`, error);
                // If it's the last attempt, throw the error
                if (attempt === maxRetries) {
                    throw error;
                }
                // If it's a timeout or network error, wait before retrying
                if (error.name === 'AbortError' || error.message.includes('fetch')) {
                    console.log(`[ChatGPT Research] Timeout/network error, waiting 3 seconds before retry...`);
                    await new Promise((resolve)=>setTimeout(resolve, 3000));
                }
            }
        }
        throw new Error('All retry attempts failed');
    }
    /**
   * Validate API key
   */ async validateApiKey() {
        // TODO: Implement API key validation
        // - Make a simple test request
        // - Check if key is valid
        console.log('[ChatGPT Research] Validating API key...');
        return true;
    }
}
// ===== PERPLEXITY API INTEGRATION =====
/**
 * Perplexity API client for web research
 */ class PerplexityResearchAPI {
    apiKey;
    // Use the correct Perplexity endpoint as of 2024
    baseUrl = 'https://api.perplexity.ai/chat/completions';
    constructor(apiKey){
        this.apiKey = apiKey;
    }
    /**
   * Execute web research using Perplexity with timeout and retry logic
   */ async executeResearch(prompt) {
        console.log('[Perplexity Research] Executing research with prompt:', prompt.substring(0, 100) + '...');
        const maxRetries = 3;
        const timeoutMs = 30000; // 30 seconds timeout
        for(let attempt = 1; attempt <= maxRetries; attempt++){
            try {
                console.log(`[Perplexity Research] Attempt ${attempt}/${maxRetries}`);
                // Create AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(()=>controller.abort(), timeoutMs);
                const response = await fetch(this.baseUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        // Use the recommended Perplexity model for best results as of 2024
                        model: 'sonar-pro',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a web research assistant specialized in gathering casino information. Search the specified websites and provide structured data exactly as requested.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 2000,
                        temperature: 0.3
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    let errorMessage = `Perplexity API error: ${response.status}`;
                    let errorBody = '';
                    try {
                        const errorData = await response.json();
                        errorBody = JSON.stringify(errorData);
                        errorMessage += ' - ' + (errorData.error?.message || errorBody);
                    } catch (e) {
                    // ignore JSON parse error
                    }
                    console.error('[Perplexity Research] Full error response:', errorBody);
                    if (response.status === 429) {
                        console.log('[Perplexity Research] Rate limit hit, waiting 5 seconds before retry...');
                        await new Promise((resolve)=>setTimeout(resolve, 5000));
                        continue;
                    }
                    // Log and throw error so the research task fails and UI shows error
                    console.error(errorMessage);
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                // Perplexity API response format may differ; adjust as needed
                const result = data.choices?.[0]?.message?.content || '';
                console.log('[Perplexity Research] Research completed successfully');
                return result;
            } catch (error) {
                console.error(`[Perplexity Research] Attempt ${attempt} failed:`, error);
                if (attempt === maxRetries) {
                    if (error instanceof Error) {
                        throw error;
                    } else {
                        throw new Error(String(error));
                    }
                }
                if (error instanceof Error && error.name === 'AbortError' || typeof error === 'object' && error !== null && 'message' in error && typeof error.message === 'string' && error.message.includes('fetch')) {
                    console.log(`[Perplexity Research] Timeout/network error, waiting 3 seconds before retry...`);
                    await new Promise((resolve)=>setTimeout(resolve, 3000));
                }
            }
        }
        throw new Error('All retry attempts failed');
    }
}
// ===== BACKGROUND TASK MANAGER =====
/**
 * Background task manager for researcher agent
 */ class ResearcherBackgroundTask {
    static tasks = new Map();
    chatgptApi;
    perplexityApi;
    config;
    constructor(config){
        this.config = config;
        this.chatgptApi = new ChatGPTResearchAPI(config.chatgptApiKey);
        this.perplexityApi = new PerplexityResearchAPI(config.perplexityApiKey);
    }
    /**
   * Start background research task
   */ async startResearch(request) {
        const taskId = request.projectId;
        // Log the start of the research task
        try {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                project_id: request.projectId,
                agent: 'researcher',
                task: 'Web research for casino information - STARTED',
                input: {
                    projectId: request.projectId,
                    brandName: request.brandName,
                    targetCountry: request.targetCountry,
                    targetLanguage: request.targetLanguage,
                    websites: RESEARCH_WEBSITES
                },
                output: null,
                status: 'pending',
                logs: {
                    startTime: new Date().toISOString()
                }
            });
        } catch (error) {
            console.error('[Researcher] Failed to log start task:', error);
        }
        // Initialize task status
        const taskStatus = {
            projectId: request.projectId,
            status: 'pending',
            progress: 0,
            startTime: new Date().toISOString()
        };
        ResearcherBackgroundTask.tasks.set(taskId, taskStatus);
        // Start research in background (don't await)
        this.executeResearchTask(request).catch(async (error)=>{
            console.error('[Researcher] Background task failed:', error);
            // Log the failure
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                    project_id: request.projectId,
                    agent: 'researcher',
                    task: 'Web research for casino information - FAILED',
                    input: {
                        projectId: request.projectId,
                        brandName: request.brandName,
                        targetCountry: request.targetCountry,
                        targetLanguage: request.targetLanguage,
                        websites: RESEARCH_WEBSITES
                    },
                    output: null,
                    status: 'error',
                    error: error.message,
                    logs: {
                        startTime: new Date().toISOString(),
                        error: error.message,
                        stack: error.stack
                    }
                });
            } catch (logError) {
                console.error('[Researcher] Failed to log error task:', logError);
            }
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error.message,
                endTime: new Date().toISOString()
            });
        });
        console.log(`[Researcher] Started background research for project: ${request.projectId}`);
    }
    /**
   * Execute research task with overall timeout protection
   */ async executeResearchTask(request) {
        const taskId = request.projectId;
        const overallTimeoutMs = 60000; // 60 seconds total timeout
        // Create a promise that rejects after timeout
        const timeoutPromise = new Promise((_, reject)=>{
            setTimeout(()=>reject(new Error('Research task timeout - taking too long')), overallTimeoutMs);
        });
        // Create the actual research promise
        const researchPromise = this.performResearch(request, taskId);
        try {
            // Race between research and timeout
            await Promise.race([
                researchPromise,
                timeoutPromise
            ]);
        } catch (error) {
            console.error('[Researcher] Research task failed or timed out:', error);
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error instanceof Error ? error.message : 'Research timeout or failed',
                endTime: new Date().toISOString()
            });
        }
    }
    /**
   * Perform the actual research work
   */ async performResearch(request, taskId) {
        try {
            // Update status to in_progress
            this.updateTaskStatus(taskId, {
                status: 'in_progress',
                progress: 10
            });
            // Log in-progress status
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                    project_id: request.projectId,
                    agent: 'researcher',
                    task: 'Web research for casino information - IN PROGRESS',
                    input: {
                        projectId: request.projectId,
                        brandName: request.brandName,
                        targetCountry: request.targetCountry,
                        targetLanguage: request.targetLanguage,
                        websites: RESEARCH_WEBSITES
                    },
                    output: null,
                    status: 'pending',
                    logs: {
                        startTime: new Date().toISOString(),
                        progress: 10
                    }
                });
            } catch (logError) {
                console.error('[Researcher] Failed to log in-progress task:', logError);
            }
            // Prepare research prompt
            const prompt = this.fillPromptTemplate(RESEARCH_PROMPT_TEMPLATE, request);
            // Update progress
            this.updateTaskStatus(taskId, {
                progress: 30
            });
            // ===== SWITCH TO PERPLEXITY HERE =====
            // To use ChatGPT, use:
            // const rawResponse = await this.chatgptApi.executeResearch(prompt);
            // To use Perplexity, use:
            const startTime = Date.now();
            const rawResponse = await this.perplexityApi.executeResearch(prompt);
            const searchTime = Date.now() - startTime;
            // Update progress
            this.updateTaskStatus(taskId, {
                progress: 70
            });
            // Parse research results
            const researchResult = this.parseResearchResponse(rawResponse, searchTime);
            // Update progress
            this.updateTaskStatus(taskId, {
                progress: 90
            });
            // Save results to database
            await this.saveResearchResults(request.projectId, researchResult);
            // Complete task
            this.updateTaskStatus(taskId, {
                status: 'completed',
                progress: 100,
                result: researchResult,
                endTime: new Date().toISOString()
            });
            console.log(`[Researcher] Completed research for project: ${request.projectId}`);
        } catch (error) {
            console.error('[Researcher] Research task failed:', error);
            this.updateTaskStatus(taskId, {
                status: 'failed',
                error: error instanceof Error ? error.message : 'Unknown error',
                endTime: new Date().toISOString()
            });
        }
    }
    /**
   * Fill prompt template with user data
   */ fillPromptTemplate(template, request) {
        return template.replace(/{project_name}/g, request.projectName).replace(/{target_country}/g, request.targetCountry).replace(/{target_language}/g, request.targetLanguage).replace(/{brand_name}/g, request.brandName);
    }
    /**
   * Parse ChatGPT response into structured data with fallback
   */ parseResearchResponse(response, searchTime) {
        console.log('[Researcher] Parsing research response...');
        console.log('[Researcher] Raw response:', response);
        try {
            // Try to extract JSON from response (handle multiple formats)
            let jsonMatch = response.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
                // Try to find JSON in code blocks
                jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonMatch) {
                    jsonMatch[0] = jsonMatch[1];
                }
            }
            if (!jsonMatch) {
                // Try to find JSON anywhere in the response
                jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    // If single object, wrap in array
                    jsonMatch[0] = `[${jsonMatch[0]}]`;
                }
            }
            if (!jsonMatch) {
                throw new Error('No JSON found in response');
            }
            const parsedData = JSON.parse(jsonMatch[0]);
            // Ensure we have an array
            const dataArray = Array.isArray(parsedData) ? parsedData : [
                parsedData
            ];
            // Extract data from parsed JSON
            const bonuses = this.extractArrayFromObject(dataArray, 'Bonuses');
            const providers = this.extractArrayFromObject(dataArray, 'Providers');
            const topSlots = this.extractArrayFromObject(dataArray, 'Top Slots');
            const logo = this.extractStringFromObject(dataArray, 'Logo');
            return {
                bonuses,
                providers,
                topSlots,
                logo,
                metadata: {
                    searchTime,
                    sourcesChecked: RESEARCH_WEBSITES,
                    timestamp: new Date().toISOString()
                }
            };
        } catch (error) {
            console.error('[Researcher] Failed to parse response:', error);
            // Return fallback data instead of empty result
            return this.getFallbackResearchData(searchTime);
        }
    }
    /**
   * Get fallback research data when API fails
   */ getFallbackResearchData(searchTime) {
        console.log('[Researcher] Using fallback research data');
        return {
            bonuses: [
                'Welcome Bonus up to $1000',
                'Free Spins on Sign Up',
                'Reload Bonus 50%',
                'VIP Cashback Program'
            ],
            providers: [
                'NetEnt',
                'Microgaming',
                'Pragmatic Play',
                'Evolution Gaming',
                'Play\'n GO'
            ],
            topSlots: [
                'Starburst',
                'Book of Dead',
                'Gonzo\'s Quest',
                'Mega Fortune',
                'Immortal Romance'
            ],
            logo: 'Casino logo available on official website',
            metadata: {
                searchTime,
                sourcesChecked: RESEARCH_WEBSITES,
                timestamp: new Date().toISOString(),
                note: 'Fallback data used due to API failure'
            }
        };
    }
    /**
   * Extract array from parsed object
   */ extractArrayFromObject(data, key) {
        for (const item of data){
            if (item[key]) {
                if (Array.isArray(item[key])) {
                    return item[key];
                }
                // Handle string values that might be comma-separated
                if (typeof item[key] === 'string') {
                    return item[key].split(',').map((s)=>s.trim()).filter(Boolean);
                }
            }
        }
        return [];
    }
    /**
   * Extract string from parsed object
   */ extractStringFromObject(data, key) {
        for (const item of data){
            if (item[key]) {
                if (typeof item[key] === 'string') {
                    return item[key];
                }
                // Handle array values, take first item
                if (Array.isArray(item[key]) && item[key].length > 0) {
                    return item[key][0];
                }
            }
        }
        return null;
    }
    /**
   * Save research results to database
   */ async saveResearchResults(projectId, result) {
        try {
            // Log agent task
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createAgentTask"])({
                project_id: projectId,
                agent: 'researcher',
                task: 'Web research for casino information',
                input: {
                    projectId,
                    websites: RESEARCH_WEBSITES
                },
                output: result,
                status: 'success',
                logs: result.metadata
            });
            // Get current project
            const project = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getProjectById"])(projectId);
            if (!project) {
                throw new Error('Project not found');
            }
            // Update project meta with research results
            const updatedMeta = {
                ...project.meta,
                research_data: result,
                research_completed_at: new Date().toISOString(),
                research_status: 'completed'
            };
            // Also update user_input with research completion flag
            const updatedUserInput = {
                ...project.user_input,
                research_completed: true,
                research_completed_at: new Date().toISOString()
            };
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2f$queries$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateProject"])(projectId, {
                meta: updatedMeta,
                user_input: updatedUserInput
            });
            console.log(`[Researcher] Saved research results for project: ${projectId}`);
        } catch (error) {
            console.error('[Researcher] Failed to save results:', error);
            throw error;
        }
    }
    /**
   * Update task status
   */ updateTaskStatus(taskId, updates) {
        const currentStatus = ResearcherBackgroundTask.tasks.get(taskId);
        if (currentStatus) {
            const updatedStatus = {
                ...currentStatus,
                ...updates
            };
            ResearcherBackgroundTask.tasks.set(taskId, updatedStatus);
        }
    }
    /**
   * Get task status
   */ static getTaskStatus(projectId) {
        return ResearcherBackgroundTask.tasks.get(projectId) || null;
    }
    /**
   * Check if task is completed
   */ static isTaskCompleted(projectId) {
        const status = ResearcherBackgroundTask.getTaskStatus(projectId);
        return status ? status.status === 'completed' : false;
    }
    /**
   * Get task result
   */ static getTaskResult(projectId) {
        const status = ResearcherBackgroundTask.getTaskStatus(projectId);
        return status && status.result ? status.result : null;
    }
}
class ResearcherAgent {
    backgroundTask;
    config;
    constructor(config){
        this.config = config;
        this.backgroundTask = new ResearcherBackgroundTask(config);
    }
    /**
   * Start research for a project (background execution)
   */ async startResearch(request) {
        await this.backgroundTask.startResearch(request);
    }
    /**
   * Get research status
   */ getResearchStatus(projectId) {
        return ResearcherBackgroundTask.getTaskStatus(projectId);
    }
    /**
   * Check if research is completed
   */ isResearchCompleted(projectId) {
        return ResearcherBackgroundTask.isTaskCompleted(projectId);
    }
    /**
   * Get research results
   */ getResearchResults(projectId) {
        return ResearcherBackgroundTask.getTaskResult(projectId);
    }
    /**
   * Wait for research completion (with timeout)
   */ async waitForCompletion(projectId, timeoutMs = 30000) {
        const startTime = Date.now();
        while(Date.now() - startTime < timeoutMs){
            const status = this.getResearchStatus(projectId);
            if (status?.status === 'completed') {
                return status.result || null;
            }
            if (status?.status === 'failed') {
                throw new Error(`Research failed: ${status.error}`);
            }
            // Wait 1 second before checking again
            await new Promise((resolve)=>setTimeout(resolve, 1000));
        }
        throw new Error('Research timeout');
    }
}
function createResearcherConfig() {
    return {
        chatgptApiKey: process.env.OPENAI_API_KEY || '',
        perplexityApiKey: process.env.PERPLEXITY_API_KEY || '',
        timeout: 30000,
        maxRetries: 3,
        enableLogging: true
    };
}
function validateResearcherConfig(config) {
    if (!config.chatgptApiKey) {
        console.error('[Researcher] Missing ChatGPT API key');
        return false;
    }
    if (config.timeout <= 0) {
        console.error('[Researcher] Invalid timeout value');
        return false;
    }
    return true;
}
function createResearchRequest(projectId, projectName, targetCountry, targetLanguage, brandName) {
    return {
        projectId,
        projectName,
        targetCountry,
        targetLanguage,
        brandName
    };
}
const __TURBOPACK__default__export__ = ResearcherAgent;
;
}),
"[project]/src/app/api/researcher/start/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "GET": ()=>GET,
    "POST": ()=>POST
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/services/researcher_agent.ts [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const body = await request.json();
        const { projectId, projectName, brandName, targetCountry, targetLanguage } = body;
        // Validate required fields
        if (!projectId || !projectName || !brandName || !targetCountry || !targetLanguage) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields: projectId, projectName, brandName, targetCountry, targetLanguage'
            }, {
                status: 400
            });
        }
        // Create researcher configuration
        const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearcherConfig"])();
        // Validate configuration
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["validateResearcherConfig"])(config)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Invalid researcher configuration - check OPENAI_API_KEY'
            }, {
                status: 500
            });
        }
        // Create researcher agent
        const researcherAgent = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ResearcherAgent"](config);
        // Create research request
        const researchRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearchRequest"])(projectId, projectName, targetCountry, targetLanguage, brandName);
        // Start background research (non-blocking)
        await researcherAgent.startResearch(researchRequest);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'Background research started successfully',
            projectId,
            startTime: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error starting background research:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        }, {
            status: 500
        });
    }
}
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        const projectId = searchParams.get('projectId');
        if (!projectId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing projectId parameter'
            }, {
                status: 400
            });
        }
        // Create researcher agent (just for status checking)
        const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createResearcherConfig"])();
        const researcherAgent = new __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$services$2f$researcher_agent$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ResearcherAgent"](config);
        // Get research status
        const status = researcherAgent.getResearchStatus(projectId);
        const isCompleted = researcherAgent.isResearchCompleted(projectId);
        const results = researcherAgent.getResearchResults(projectId);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            projectId,
            status,
            isCompleted,
            results,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('Error getting research status:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        }, {
            status: 500
        });
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__95beacbd._.js.map